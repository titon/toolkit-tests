/*! Titon Toolkit v1.4.1 | BSD-3 License | http://titon.io */
(function(window, $) {
    "use strict";
    var hasTransition = function() {
        var prefixes = "transition WebkitTransition MozTransition OTransition msTransition".split(" "), style = document.createElement("div").style;
        for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] in style) {
                return prefixes[i];
            }
        }
        return false;
    }();
    var Toolkit = {
        version: "1.4.1",
        build: "hvyewapx",
        vendor: "",
        aria: true,
        messages: {
            loading: "Loading...",
            error: "An error has occurred!"
        },
        hasTransition: hasTransition,
        transitionEnd: function() {
            var eventMap = {
                WebkitTransition: "webkitTransitionEnd",
                OTransition: "oTransitionEnd otransitionend"
            };
            return eventMap[hasTransition] || "transitionend";
        }(),
        isTouch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch),
        isRetina: window.devicePixelRatio > 1,
        autobox: function(value) {
            if (typeOf(value) === "null") {
                value = null;
            } else if (value === "true") {
                value = true;
            } else if (value === "false") {
                value = false;
            } else if (isNaN(value)) {
                value = String.from(value);
            } else {
                value = Number.from(value);
            }
            return value;
        },
        create: function(component, callback, collection) {
            var name = component, key = "$" + name;
            if (collection) {
                if (Elements.prototype[name]) {
                    name = "toolkit" + name.charAt(0).toUpperCase() + name.slice(1);
                }
                Elements.implement(name, function() {
                    var instance = callback.apply(this, arguments);
                    return this.each(function(el) {
                        if (!el[key]) {
                            el[key] = instance;
                        }
                    });
                });
            } else {
                if (Element.prototype[name]) {
                    name = "toolkit" + name.charAt(0).toUpperCase() + name.slice(1);
                }
                Element.implement(name, function() {
                    if (!this[key]) {
                        this[key] = callback.apply(this, arguments);
                    }
                    return this;
                });
            }
        }
    };
    window.Toolkit = Toolkit;
    var vendor = Toolkit.vendor;
    Element.implement({
        toolkit: function(component, method, args) {
            var instance = this["$" + component];
            if (!instance) {
                return null;
            }
            if (method && instance[method]) {
                instance[method].apply(instance, Array.from(args));
            }
            return instance;
        },
        reveal: function() {
            return this.swapClass("hide", "show").aria("hidden", false);
        },
        conceal: function() {
            return this.swapClass("show", "hide").aria("hidden", true);
        },
        isShown: function() {
            return this.getStyle("visibility") !== "hidden";
        },
        aria: function(key, value) {
            if (!Toolkit.aria) {
                return this;
            }
            if (value === true) {
                value = "true";
            } else if (value === false) {
                value = "false";
            }
            return this.set("aria-" + key, value);
        }.overloadSetter(),
        positionTo: function(position, relativeTo, baseOffset, isMouse) {
            var offset = baseOffset || {
                left: 0,
                top: 0
            }, relHeight = 0, relWidth = 0, eSize = this.getDimensions({
                computeSize: true,
                styles: [ "padding", "border", "margin" ]
            });
            if (typeOf(relativeTo) === "domevent") {
                offset.left += relativeTo.page.x;
                offset.top += relativeTo.page.y;
            } else {
                var relOffset = relativeTo.getPosition(), newPosition = position, wSize = window.getSize(), wsTop = window.getScroll().top;
                offset.left += relOffset.x;
                offset.top += relOffset.y;
                relHeight = relativeTo.getHeight();
                relWidth = relativeTo.getWidth();
                if (relOffset.top - eSize.totalHeight - wsTop < 0) {
                    newPosition = newPosition.replace("top", "bottom");
                } else if (relOffset.top + relHeight + eSize.totalHeight > wSize.y) {
                    newPosition = newPosition.replace("bottom", "top");
                }
                if (relOffset.left - eSize.totalWidth < 0) {
                    newPosition = newPosition.replace("left", "right");
                } else if (relOffset.left + relWidth + eSize.totalWidth > wSize.x) {
                    newPosition = newPosition.replace("right", "left");
                }
                if (position !== newPosition) {
                    this.removeClass(position).addClass(newPosition).set("data-new-position", newPosition);
                    position = newPosition;
                }
            }
            var parts = position.split("-"), edge = {
                y: parts[0],
                x: parts[1]
            };
            if (edge.y === "top") {
                offset.top -= eSize.totalHeight;
            } else if (edge.y === "bottom") {
                offset.top += relHeight;
            } else if (edge.y === "center") {
                offset.top -= Math.round(eSize.totalHeight / 2 - relHeight / 2);
            }
            if (edge.x === "left") {
                offset.left -= eSize.totalWidth;
            } else if (edge.x === "right") {
                offset.left += relWidth;
            } else if (edge.x === "center") {
                offset.left -= Math.round(eSize.totalWidth / 2 - relWidth / 2);
            }
            if (isMouse) {
                if (edge.y === "center") {
                    if (edge.x === "left") {
                        offset.left -= 15;
                    } else if (edge.x === "right") {
                        offset.left += 15;
                    }
                }
                if (edge.x === "center") {
                    if (edge.y === "top") {
                        offset.top -= 10;
                    } else if (edge.y === "bottom") {
                        offset.top += 20;
                    }
                }
            }
            return this.setStyles(offset);
        }
    });
    Array.implement({
        chunk: function(size) {
            var array = this;
            return [].concat.apply([], array.map(function(elem, i) {
                return i % size ? [] : [ array.slice(i, i + size) ];
            }));
        }
    });
    Number.implement({
        bound: function(max, min) {
            var value = this;
            min = min || 0;
            if (value >= max) {
                value = 0;
            } else if (value < min) {
                value = max - 1;
            }
            return value;
        }
    });
    Function.implement({
        debounce: function(threshold, immediate) {
            var timeout, func = this;
            return function() {
                var context = this, args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                }, threshold || 150);
                if (immediate && !timeout) {
                    func.apply(context, args);
                }
            };
        }
    });
    Element.Events.clickout = function() {
        var elements = new Elements();
        function isOut(e) {
            var trigger = true;
            elements.each(function(el) {
                if (trigger) {
                    trigger = el !== e.target && el.getElements(e.target).length === 0;
                }
            });
            return trigger;
        }
        function clickOut(e) {
            if (isOut(e)) {
                elements.fireEvent("clickout", [ e.target ]);
            }
        }
        return {
            base: "click",
            condition: isOut,
            onAdd: function() {
                elements.push(this);
                if (elements.length === 1) {
                    document.addEvent("click", clickOut);
                }
            },
            onRemove: function() {
                elements.pop(this);
                if (elements.length === 0) {
                    document.removeEvent("click", clickOut);
                }
            }
        };
    }();
    Element.Properties.html.set = function(html) {
        var type = typeOf(html);
        if (type === "element") {
            this.innerHTML = "";
            this.appendChild(html);
            return this;
        }
        if (type === "string" && html.match(/^#[a-z0-9_\-\.:]+$/i)) {
            html = document.getElement(html).get("html");
        } else if (type === "array") {
            html = html.join("");
        }
        this.innerHTML = html;
        return this;
    };
    Element.NativeEvents.transitionend = 2;
    Toolkit.Component = new Class({
        Implements: [ Events, Options ],
        Binds: [ "onShow", "onHide", "position" ],
        uid: 0,
        cache: {},
        events: {},
        enabled: false,
        element: null,
        nodes: null,
        node: null,
        options: {
            cache: true,
            context: null,
            delegate: "",
            className: "",
            template: "",
            templateFrom: ""
        },
        runtime: {},
        initialize: function(options) {
            this.setOptions(options || {});
            var className = this.className();
            Toolkit[className].count = Toolkit[className].count || 0;
            this.uid = Toolkit[className].count += 1;
            this.cssClass = className.hyphenate().slice(1);
            this.keyName = className.charAt(0).toLowerCase() + className.slice(1);
        },
        bindEvents: function(type) {
            var self = this, options = this.options, event, keys, context, selector, funcs, win = window, doc = document, method = type === "on" ? "addEvent" : "removeEvent";
            Object.each(this.events, function(value, key) {
                funcs = typeOf(value) === "array" ? value : [ value ];
                key = key.replace("{mode}", options.mode);
                key = key.replace("{selector}", options.delegate || "");
                keys = key.split(" ");
                event = keys.shift();
                context = keys.shift();
                selector = keys.join(" ").replace("@", vendor);
                if (typeof self[context] !== "undefined") {
                    context = self[context];
                } else if (context === "window") {
                    context = win;
                } else if (context === "document") {
                    context = doc;
                }
                if (typeOf(context) === "array" && !context.length) {
                    return;
                }
                funcs.each(function(func) {
                    if (typeOf(func) !== "function") {
                        func = self[func];
                    }
                    if (event === "ready") {
                        win[method]("domready", func);
                    } else if (event === "clickout") {
                        $$(selector || context)[method](event, func);
                    } else if (selector) {
                        context[method](event + ":relay(" + selector + ")", func);
                    } else {
                        context[method](event, func);
                    }
                });
            });
            return this;
        },
        className: function() {
            return Object.keyOf(window.Toolkit, this.$constructor);
        },
        createElement: function() {
            var options = this.options, template;
            if (this.element) {
                return this;
            }
            if (options.templateFrom) {
                if (typeOf(options.templateFrom) === "element") {
                    template = options.templateFrom;
                } else {
                    template = document.getElement(options.templateFrom);
                }
            }
            if (!template && options.template) {
                template = this.parseTemplate(options.template);
                if (template) {
                    template.conceal().inject(document.body);
                }
            }
            if (template) {
                if (options.className) {
                    template.addClass(options.className);
                }
                if (options.animation) {
                    template.addClass(options.animation);
                }
                template.set("id", this.id());
                this.element = template;
            } else {
                throw new Error(this.className() + " failed to create template element");
            }
            this.created = true;
            return this;
        },
        destroy: function() {
            this.fireEvent("destroy");
            this.hide();
            if (this.doDestroy) {
                this.doDestroy();
            }
            this.disable();
            if (this.created) {
                this.element.dispose();
            }
            var key = this.keyName;
            if (this.nodes) {
                this.nodes.each(function(node) {
                    delete node["$" + key];
                });
            } else if (this.element) {
                delete this.element["$" + key];
            }
            return this;
        },
        disable: function() {
            if (this.enabled) {
                this.bindEvents("off");
            }
            this.enabled = false;
            return this;
        },
        enable: function() {
            if (!this.enabled) {
                this.bindEvents("on");
            }
            this.enabled = true;
            return this;
        },
        hide: function(callback) {
            if (this.element && this.element !== document.body) {
                this.element.conceal();
            }
            if (typeOf(callback) === "function") {
                callback();
            }
            this.fireEvent("hide");
            return this;
        },
        id: function() {
            var list = Array.slice(arguments);
            list.unshift("toolkit", this.cssClass, this.uid);
            return list.join("-");
        },
        inheritOptions: function(options, element) {
            var key, value, obj = {};
            for (key in options) {
                if (key === "context" || key === "template") {
                    continue;
                }
                value = element.get(("data-" + this.keyName + "-" + key).toLowerCase());
                if (typeOf(value) !== "null") {
                    obj[key] = Toolkit.autobox(value);
                }
            }
            return Object.merge({}, options, obj);
        },
        isVisible: function() {
            return this.element && this.element.isShown();
        },
        parseTemplate: function(template) {
            if (!template) {
                return null;
            }
            if (typeOf(template) === "element") {
                return template;
            }
            var element = Elements.from(template);
            if (element[0]) {
                return element[0];
            }
            throw new Error(this.className() + " template failed to parse");
        },
        position: function(content) {
            this.element.set("html", content);
            this.fireEvent("load", content);
            return this;
        },
        process: function(content) {
            this.hide();
            if (content.callback) {
                var namespaces = content.callback.split("."), func = window, prev = func;
                for (var i = 0; i < namespaces.length; i++) {
                    prev = func;
                    func = func[namespaces[i]];
                }
                func.call(prev, content);
            }
            this.fireEvent("process", content);
            return this;
        },
        readOption: function(element, key) {
            var value = element.get(("data-" + this.keyName + "-" + key).toLowerCase());
            if (typeOf(value) === "null") {
                value = this.options[key];
            } else {
                value = Toolkit.autobox(value);
            }
            return value;
        },
        readValue: function(element, query) {
            if (!query) {
                return null;
            }
            if (typeOf(query) === "function") {
                return query.call(this, element);
            }
            return element.get(query);
        },
        requestData: function(options, before, done, fail) {
            var url = options.url || options;
            var ajax = Object.merge({
                url: url,
                method: "GET",
                evalScripts: true,
                onRequest: before || function() {
                    this.cache[url] = true;
                    this.element.addClass("is-loading").aria("busy", true);
                }.bind(this)
            }, options);
            if (typeOf(this.options.ajax) === "object") {
                ajax = Object.merge({}, this.options.ajax, ajax);
            }
            var self = this, cache = ajax.method.toUpperCase() === "GET" && this.options.cache;
            ajax.onSuccess = done || function(response) {
                var contentType = this.xhr.getResponseHeader("Content-Type");
                self.element.removeClass("is-loading").aria("busy", false);
                if (contentType.indexOf("text/html") >= 0) {
                    if (cache) {
                        self.cache[url] = response;
                    } else {
                        delete self.cache[url];
                    }
                    self.position(response);
                } else {
                    delete self.cache[url];
                    if (contentType === "application/json") {
                        response = JSON.parse(response);
                    }
                    self.process(response);
                }
            };
            ajax.onFailure = fail || function() {
                delete this.cache[url];
                this.element.removeClass("is-loading").addClass("has-failed").aria("busy", false);
                this.position(Toolkit.messages.error);
            }.bind(this);
            new Request(ajax).send();
            return this;
        },
        setOptions: function(options, inheritFrom) {
            options = Object.merge({}, this.options, options || {});
            if (inheritFrom) {
                options = this.inheritOptions(options, inheritFrom);
            }
            if (options.mode && options.mode === "hover") {
                if (Toolkit.isTouch) {
                    options.mode = "click";
                } else {
                    options.mode = "mouseenter";
                }
            }
            if (this.addEvent) {
                for (var option in options) {
                    if (typeOf(options[option]) !== "function" || !/^on[A-Z]/.test(option)) {
                        continue;
                    }
                    this.addEvent(option, options[option]);
                    delete options[option];
                }
            }
            this.options = options;
            return this;
        },
        show: function(node) {
            this.node = node;
            this.element.reveal();
            this.fireEvent("show");
            return this;
        },
        onHide: function(e) {
            if (typeOf(e) === "domevent") {
                e.preventDefault();
            }
            var element = this.element;
            if (element && (!element.isShown() || element.hasClass("is-loading"))) {
                return;
            }
            this.hide();
        },
        onShow: function(e, node) {
            if (!this.enabled) {
                return;
            }
            node = node || e.target;
            if (this.isVisible()) {
                if (Toolkit.isTouch) {
                    if (node !== this.node || this.node.get("tag") !== "a") {
                        e.preventDefault();
                    }
                } else {
                    e.preventDefault();
                }
                if (this.options.mode === "click") {
                    this.hide();
                }
                if (node === this.node) {
                    return;
                }
            } else if (typeOf(e) === "domevent") {
                e.preventDefault();
            }
            this.show(node);
        }
    });
    Toolkit.Accordion = new Class({
        Extends: Toolkit.Component,
        headers: [],
        sections: [],
        index: 0,
        options: {
            mode: "click",
            defaultIndex: 0,
            multiple: false,
            collapsible: false
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = options = this.inheritOptions(this.options, element);
            var sections = element.getElements("." + vendor + "accordion-section"), headers = element.getElements("." + vendor + "accordion-header"), self = this;
            this.headers = headers;
            this.sections = sections;
            element.set("role", "tablist");
            headers.each(function(header, index) {
                header.set("data-index", index).set("role", "tab").set("id", self.id("header", index)).aria({
                    controls: self.id("section", index),
                    selected: false,
                    expanded: false
                });
            });
            sections.each(function(section, index) {
                section.set("data-height", section.getHeight()).set("role", "tabpanel").set("id", self.id("section", index)).aria("labelledby", self.id("header", index)).conceal();
            });
            this.events = {
                "{mode} element .@accordion-header": "onShow"
            };
            this.enable();
            this.fireEvent("init");
            this.jump(options.defaultIndex);
        },
        doDestroy: function() {
            this.element.reveal();
            this.headers.getParent().removeClass("is-active");
            this.sections.removeProperty("style").reveal();
        },
        jump: function(index) {
            index = Number.from(index).bound(this.headers.length);
            this.fireEvent("jump", index);
            return this.show(this.headers[index]);
        },
        show: function(header) {
            var options = this.options, parent = header.getParent(), section = header.getNext(), index = header.get("data-index"), height = section.get("data-height").toInt(), closed = {
                selected: false,
                expanded: false
            }, open = {
                selected: true,
                expanded: true
            };
            if (options.mode === "click" && (options.multiple || options.collapsible && this.node === header)) {
                if (section.isShown() && this.node) {
                    section.setStyle("max-height", 0).conceal();
                    parent.removeClass("is-active");
                    header.aria(closed);
                } else {
                    section.setStyle("max-height", height).reveal();
                    parent.addClass("is-active");
                    header.aria(open);
                }
            } else {
                if (this.node === header) {
                    return this;
                }
                this.sections.setStyle("max-height", 0).conceal();
                section.setStyle("max-height", height).reveal();
                this.headers.aria(closed);
                header.aria(open);
                this.element.getChildren("li").removeClass("is-active");
                parent.addClass("is-active");
            }
            this.index = index;
            this.node = header;
            this.fireEvent("show", [ section, header, index ]);
            return this;
        },
        onShow: function(e) {
            e.preventDefault();
            var target = e.target, headers = this.headers;
            while (!headers.contains(target)) {
                target = target.getParent();
            }
            if (!target) {
                return;
            }
            this.show(target);
        }
    });
    Toolkit.create("accordion", function(options) {
        return new Toolkit.Accordion(this, options);
    });
    Toolkit.Blackout = new Class({
        Extends: Toolkit.Component,
        count: 0,
        loader: null,
        message: null,
        options: {
            loader: "bar-wave",
            waveCount: 5,
            template: '<div class="' + vendor + 'blackout"></div>',
            templateFrom: "#toolkit-blackout-1"
        },
        initialize: function(options) {
            this.parent(options);
            this.createElement();
            this.createLoader();
            this.fireEvent("init");
        },
        createLoader: function() {
            var options = this.options, count = options.loader === "bubble-spinner" ? 8 : options.waveCount;
            this.loader = new Element("div." + vendor + "loader." + options.loader).inject(this.element);
            var spans = "", i;
            for (i = 0; i < count; i++) {
                spans += "<span></span>";
            }
            if (options.loader === "bubble-spinner") {
                new Element("div." + vendor + "loader-spinner").set("html", spans).inject(this.loader);
            } else {
                this.loader.set("html", spans);
            }
            this.message = new Element("div." + vendor + "loader-message").set("html", Toolkit.messages.loading).inject(this.loader);
        },
        hide: function() {
            var count = this.count - 1;
            if (count <= 0) {
                this.count = 0;
                this.element.conceal();
                this.hideLoader();
            } else {
                this.count = count;
            }
            this.fireEvent("hide", count <= 0);
            return this;
        },
        hideLoader: function() {
            this.loader.conceal();
            this.fireEvent("hideLoader");
            return this;
        },
        show: function() {
            var show = false;
            this.count++;
            if (this.count === 1) {
                this.element.reveal();
                show = true;
            }
            this.showLoader();
            this.fireEvent("show", show);
            return this;
        },
        showLoader: function() {
            this.loader.reveal();
            this.fireEvent("showLoader");
            return this;
        }
    });
    var blackout = null;
    Toolkit.Blackout.factory = function(options) {
        if (blackout) {
            return blackout;
        }
        return blackout = new Toolkit.Blackout(options);
    };
    window.Cache = new Class({
        storage: null,
        setStorage: function(type) {
            if (!window.JSON) {
                throw new Error("JSON is required for caching and storage");
            }
            switch (type.toLowerCase()) {
              case "local":
              case "localstorage":
                if (window.localStorage) {
                    try {
                        window.localStorage.setItem("_temp_", "Titon");
                        window.localStorage.removeItem("_temp_");
                        this.storage = window.localStorage;
                        return;
                    } catch (LocalStorageError) {}
                }

              case "session":
              case "sessionstorage":
                if (window.sessionStorage) {
                    try {
                        window.sessionStorage.setItem("_temp_", "Titon");
                        window.sessionStorage.removeItem("_temp_");
                        this.storage = window.sessionStorage;
                        return;
                    } catch (SessionStorageError) {}
                }

              default:
                this.storage = function() {
                    var memory = {}, length = 0;
                    return {
                        length: length,
                        clear: function() {
                            memory = {};
                            length = 0;
                        },
                        getItem: function(key) {
                            return memory[key] || null;
                        },
                        setItem: function(key, value) {
                            memory[key] = value;
                            length++;
                        },
                        removeItem: function(key) {
                            delete memory[key];
                            length--;
                        }
                    };
                }();
                break;
            }
        },
        cacheSize: function() {
            return this.storage.length || 0;
        },
        flushCache: function() {
            if (this.storage) {
                this.storage.clear();
            }
        },
        getCache: function(key) {
            if (this.storage && key) {
                var value = this.storage.getItem(key);
                if (value) {
                    return JSON.parse(value);
                }
            }
            return null;
        },
        hasCache: function(key) {
            return this.storage && this.storage.getItem(key);
        },
        setCache: function(key, value) {
            if (this.storage && key) {
                try {
                    this.storage.setItem(key, JSON.stringify(value || ""));
                    return true;
                } catch (OverflowError) {}
            }
            return false;
        },
        removeCache: function(key) {
            if (this.storage && key) {
                this.storage.removeItem(key);
            }
        }
    });
    Toolkit.Carousel = new Class({
        Extends: Toolkit.Component,
        Binds: [ "next", "prev", "start", "stop", "resize", "onCycle", "onJump", "onKeydown", "onSwipe" ],
        stopped: false,
        itemsWrapper: null,
        itemsList: null,
        items: [],
        tabsWrapper: null,
        tabs: [],
        prevButton: null,
        nextButton: null,
        index: 0,
        timer: null,
        options: {
            animation: "slide",
            duration: 5e3,
            autoCycle: true,
            stopOnHover: true
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = options = this.inheritOptions(this.options, element);
            var items, self = this;
            this.items = items = element.getElements("." + vendor + "carousel-items li").each(function(item, index) {
                item.set({
                    role: "tabpanel",
                    id: self.id("item", index)
                }).aria("hidden", index > 0);
            });
            element.getElements("." + vendor + "carousel-tabs").set("role", "tablist");
            this.tabs = element.getElements("." + vendor + "carousel-tabs a").each(function(tab, index) {
                tab.set({
                    "data-index": index,
                    role: "tab",
                    id: self.id("tab", index)
                }).aria({
                    controls: self.id("item", index),
                    selected: false,
                    expanded: false
                });
            });
            element.aria("live", options.autoCycle ? "assertive" : "off").addClass(options.animation);
            this.events = {
                "keydown window": "onKeydown",
                "swipe element": "onSwipe",
                "click element .@carousel-tabs a": "onJump",
                "click element .@carousel-next": "next",
                "click element .@carousel-prev": "prev"
            };
            if (options.stopOnHover) {
                this.events["mouseenter element"] = "stop";
                this.events["mouseleave element"] = "start";
            }
            this.enable();
            this.fireEvent("init");
            switch (options.animation) {
              case "fade":
                items[0].reveal();
                break;

              case "slide":
                items[0].getParent().setStyle("width", items.length * 100 + "%");
                items.setStyle("width", 100 / items.length + "%");
                break;
            }
            this.reset().start();
        },
        doDestroy: function() {
            clearInterval(this.timer);
            this.stop();
            this.element.reveal();
        },
        jump: function(index) {
            index = Number.from(index).bound(this.items.length);
            if (index === this.index) {
                return this;
            }
            this.tabs.removeClass("is-active").aria({
                expanded: false,
                selected: false
            });
            if (this.tabs[index]) {
                this.tabs[index].addClass("is-active").aria({
                    expanded: true,
                    selected: true
                });
            }
            this.items.aria("hidden", true);
            if (this.items[index]) {
                this.items[index].aria("hidden", false);
            }
            var animation = this.options.animation;
            if (animation === "fade") {
                this.items.removeClass("show");
                this.items[index].reveal();
            } else {
                this.items.getParent().setStyle(animation === "slide-up" ? "top" : "left", -(index * 100) + "%");
            }
            this.index = index;
            this.reset();
            this.fireEvent("jump", index);
            return this;
        },
        next: function() {
            this.jump(this.index + 1);
            return this;
        },
        prev: function() {
            this.jump(this.index - 1);
            return this;
        },
        reset: function() {
            if (this.options.autoCycle) {
                clearInterval(this.timer);
                this.timer = setInterval(this.onCycle, this.options.duration);
            }
            return this;
        },
        start: function() {
            this.element.removeClass("is-stopped");
            this.stopped = false;
            this.fireEvent("start");
            return this;
        },
        stop: function() {
            this.element.addClass("is-stopped");
            this.stopped = true;
            this.fireEvent("stop");
            return this;
        },
        onCycle: function() {
            if (!this.stopped) {
                this.fireEvent("cycle", this.index);
                this.next();
            }
        },
        onJump: function(e) {
            e.preventDefault();
            this.jump(e.target.get("data-index") || 0);
        },
        onKeydown: function(e) {
            if ([ "up", "down", "left", "right" ].contains(e.key)) {
                e.preventDefault();
            } else {
                return;
            }
            switch (e.key) {
              case "up":
                this.jump(0);
                break;

              case "down":
                this.jump(-1);
                break;

              case "left":
                this.prev();
                break;

              case "right":
                this.next();
                break;
            }
        },
        onSwipe: function(e) {
            if (e.direction === "left") {
                this.next();
            } else if (e.direction === "right") {
                this.prev();
            }
        }
    });
    Toolkit.create("carousel", function(options) {
        return new Toolkit.Carousel(this, options);
    });
    Toolkit.Drop = new Class({
        Extends: Toolkit.Component,
        options: {
            delegate: ".js-drop",
            getTarget: "data-drop",
            hideOpened: true
        },
        initialize: function(elements, options) {
            this.parent(options);
            this.nodes = elements;
            this.events = {
                "clickout document .@drop": "onHide",
                "clickout document {selector}": "onHide",
                "{mode} document {selector}": "onShow"
            };
            this.enable();
            this.fireEvent("init");
        },
        hide: function() {
            return this.parent(function() {
                if (this.node) {
                    this.node.aria({
                        selected: false,
                        expanded: false
                    }).removeClass("is-active");
                }
            }.bind(this));
        },
        show: function(node) {
            this.parent(node);
            this.node.aria({
                selected: true,
                expanded: true
            }).addClass("is-active");
            return this;
        },
        onShow: function(e, node) {
            if (typeOf(e) === "domevent") {
                e.preventDefault();
            }
            var target = this.readValue(node, this.options.getTarget);
            if (!target || target.substr(0, 1) !== "#") {
                return;
            }
            if (this.options.hideOpened && this.node && this.node !== node) {
                this.hide();
            }
            this.element = document.id(target.slice(1));
            this.node = node;
            if (!this.isVisible()) {
                this.show(node);
            } else {
                this.hide();
            }
        }
    });
    Toolkit.create("drop", function(options) {
        return new Toolkit.Drop(this, options);
    }, true);
    window.Timers = new Class({
        timers: {},
        $timers: {},
        addTimer: function(key, fn) {
            this.timers[key] = Function.from(fn);
            return this;
        },
        addTimers: function(timers) {
            for (var key in timers) {
                this.addTimer(key, timers[key]);
            }
            return this;
        },
        startTimer: function(key, delay, args) {
            this.clearTimer(key);
            if (this.timers[key]) {
                this.$timers[key] = this.timers[key].delay(delay, this, args);
            }
            return this;
        },
        startInterval: function(key, interval, args) {
            this.clearTimer(key);
            if (this.timers[key]) {
                this.$timers[key] = this.timers[key].periodical(interval, this, args);
            }
            return this;
        },
        clearTimer: function(key, fn, args) {
            window.clearTimeout(this.$timers[key]);
            delete this.$timers[key];
            if (typeOf(fn) === "function") {
                fn.apply(this, args || []);
            }
            return this;
        },
        clearTimers: function(timers) {
            if (timers) {
                Array.from(timers).each(function(value) {
                    this.clearTimer(value);
                }, this);
            } else {
                Object.each(this.$timers, function(value, key) {
                    this.clearTimer(key);
                }, this);
            }
            return this;
        },
        removeTimer: function(key) {
            delete this.timers[key];
            return this;
        },
        removeTimers: function(timers) {
            Array.from(timers).each(function(value) {
                this.removeTimer(value);
            }, this);
            return this;
        }
    });
    Toolkit.Flyout = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onEnter", "onLeave" ],
        Implements: [ Timers ],
        current: null,
        menus: {},
        data: [],
        dataMap: {},
        options: {
            delegate: ".js-flyout",
            mode: "hover",
            getUrl: "href",
            xOffset: 0,
            yOffset: 0,
            showDelay: 350,
            hideDelay: 1e3,
            itemLimit: 15,
            template: '<div class="flyout"></div>'
        },
        initialize: function(elements, url, options) {
            if (Toolkit.isTouch) {
                return;
            }
            this.parent(options);
            this.nodes = elements;
            if (!url) {
                throw new Error("Flyout URL required to download sitemap JSON");
            }
            options = this.options;
            this.addTimers({
                show: this.position,
                hide: this.onHide
            });
            if (options.mode === "click") {
                this.events["click document {selector}"] = "onShow";
            } else {
                this.events["mouseenter document {selector}"] = [ "onShow", "onEnter" ];
                this.events["mouseleave document {selector}"] = "onLeave";
            }
            this.enable();
            this.fireEvent("init");
            new Request.JSON({
                url: url,
                secure: true,
                onSuccess: this.load.bind(this)
            }).get();
        },
        doDestroy: function() {
            Object.each(this.menus, function(menu) {
                menu.dispose();
            });
            this.clearTimer("show");
            this.clearTimer("hide");
        },
        hide: function() {
            this.clearTimers();
            if (this.node) {
                this.node.removeClass("is-active");
            }
            if (!this.current || !this.isVisible()) {
                return this;
            }
            this.menus[this.current].conceal();
            this.fireEvent("hide");
            this.current = null;
            return this;
        },
        isVisible: function() {
            if (this.current && this.menus[this.current]) {
                this.element = this.menus[this.current];
            }
            return this.parent();
        },
        load: function(data, depth) {
            depth = depth || 0;
            if (depth === 0) {
                this.data = data;
            }
            if (data.url) {
                this.dataMap[data.url] = data;
            }
            if (data.children) {
                for (var i = 0, l = data.children.length; i < l; i++) {
                    this.load(data.children[i], depth + 1);
                }
            }
            return this;
        },
        position: function() {
            var target = this.current, options = this.options;
            if (!this.menus[target]) {
                return this;
            }
            var menu = this.menus[target], height = menu.getDimensions().height, coords = this.node.getCoordinates(), x = coords.left + options.xOffset, y = coords.top + options.yOffset + coords.height, windowScroll = window.getScrollSize();
            if (y > windowScroll.y / 2) {
                y = coords.top - options.yOffset - height;
            }
            menu.setPosition({
                x: x,
                y: y
            }).reveal();
            this.fireEvent("show");
            return this;
        },
        show: function(node) {
            var target = this._getTarget(node);
            if (this.current && target !== this.current) {
                this.hide();
                this.startTimer("show", this.options.showDelay);
            }
            this.node = node;
            if (!this._getMenu()) {
                return this;
            }
            this.node.addClass("is-active");
            if (this.options.mode === "click") {
                this.position();
            }
            return this;
        },
        _buildMenu: function(parent, data) {
            if (!data.children || !data.children.length) {
                return null;
            }
            var options = this.options, menu = this.parseTemplate(options.template), groups = [], ul, li, tag, limit = options.itemLimit;
            menu.set("role", "menu").aria("hidden", true);
            if (options.className) {
                menu.addClass(options.className);
            }
            if (parent === document.body) {
                menu.addClass("is-root");
            } else {
                menu.aria("expanded", false);
            }
            if (limit && data.children.length > limit) {
                groups = data.children.chunk(limit);
            } else {
                groups.push(data.children);
            }
            for (var g = 0, group; group = groups[g]; g++) {
                ul = new Element("ul");
                for (var i = 0, l = group.length, child; i < l; i++) {
                    child = group[i];
                    li = new Element("li");
                    if (child.url) {
                        tag = new Element("a", {
                            text: child.title,
                            href: child.url,
                            role: "menuitem"
                        });
                        new Element("span").addClass(child.icon || "caret-right").inject(tag, "top");
                    } else {
                        tag = new Element("span", {
                            text: child.title,
                            role: "presentation"
                        });
                        li.addClass(vendor + "flyout-heading");
                    }
                    if (child.attributes) {
                        tag.set(child.attributes);
                    }
                    if (child.className) {
                        li.addClass(child.className);
                    }
                    li.grab(tag).inject(ul);
                    if (child.children && child.children.length) {
                        this._buildMenu(li, child);
                        li.addClass("has-children").aria("haspopup", true).addEvent("mouseenter", this.onPositionChild.bind(this, li)).addEvent("mouseleave", this.onHideChild.bind(this, li));
                    }
                }
                menu.grab(ul);
            }
            menu.inject(parent);
            return menu;
        }.protect(),
        _getMenu: function() {
            var target = this._getTarget();
            if (this.menus[target]) {
                this.current = target;
                return this.menus[target];
            }
            if (this.dataMap[target]) {
                var menu = this._buildMenu(document.body, this.dataMap[target]);
                if (!menu) {
                    return null;
                }
                menu.conceal();
                if (this.options.mode !== "click") {
                    menu.addEvents({
                        mouseenter: function() {
                            this.clearTimer("hide");
                        }.bind(this),
                        mouseleave: function() {
                            this.startTimer("hide", this.options.hideDelay);
                        }.bind(this)
                    });
                }
                this.current = target;
                this.menus[target] = menu;
                return this.menus[target];
            }
            return null;
        }.protect(),
        _getTarget: function(node) {
            node = node || this.node;
            return this.readValue(node, this.options.getUrl) || node.get("href");
        }.protect(),
        onEnter: function() {
            this.clearTimer("hide").startTimer("show", this.options.showDelay);
        },
        onHideChild: function(parent) {
            parent.removeClass("is-open");
            parent.getChildren("." + vendor + "flyout").removeProperty("style").aria({
                expanded: false,
                hidden: true
            });
            this.fireEvent("hideChild", parent);
        },
        onLeave: function() {
            this.clearTimer("show").startTimer("hide", this.options.showDelay);
        },
        onPositionChild: function(parent) {
            var menu = parent.getElement("." + vendor + "flyout");
            if (!menu) {
                return;
            }
            menu.aria({
                expanded: true,
                hidden: false
            });
            var children = menu.getChildren("ul");
            menu.setStyle("width", children.getWidth()[0] * children.length + "px");
            var windowScroll = window.getScrollSize(), windowSize = window.getCoordinates(), parentSize = parent.getCoordinates(), childSize = menu.getCoordinates();
            var hWidth = parentSize.right + childSize.width;
            if (hWidth >= windowSize.width) {
                menu.addClass("push-left");
            } else {
                menu.removeClass("push-left");
            }
            if (parentSize.top > windowScroll.y / 2) {
                menu.setStyle("top", "-" + (childSize.height - parentSize.height) + "px");
            } else {
                menu.setStyle("top", 0);
            }
            parent.addClass("is-open");
            this.fireEvent("showChild", parent);
        }
    });
    Toolkit.create("flyout", function(url, options) {
        return new Toolkit.Flyout(this, url, options);
    }, true);
    Toolkit.Input = new Class({
        Extends: Toolkit.Component,
        wrapper: null,
        input: null,
        options: {
            checkbox: 'input[type="checkbox"]',
            radio: 'input[type="radio"]',
            select: "select",
            copyClasses: true
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = options = this.inheritOptions(this.options, element);
            if (options.checkbox) {
                element.getElements(options.checkbox).inputCheckbox(options);
            }
            if (options.radio) {
                element.getElements(options.radio).inputRadio(options);
            }
            if (options.select) {
                element.getElements(options.select).inputSelect(options);
            }
            this.enable();
            this.fireEvent("init");
        },
        buildWrapper: function(element) {
            this.wrapper = new Element("div." + vendor + "custom-input").wraps(element);
            if (this.options.copyClasses) {
                this.copyClasses(element, this.wrapper);
            }
            return this;
        },
        copyClasses: function(from, to) {
            var classes = (from.get("class") || "").replace(/\binput\b/, "").trim();
            if (classes) {
                to.addClass(classes);
            }
            return this;
        },
        doDestroy: function() {
            var options = this.options, element = this.element;
            if (this.className() === "Input") {
                this.element.reveal();
                if (options.checkbox) {
                    element.getElements(options.checkbox).each(function(el) {
                        el.toolkit("inputCheckbox", "destroy");
                    });
                }
                if (options.radio) {
                    element.getElements(options.radio).each(function(el) {
                        el.toolkit("inputRadio", "destroy");
                    });
                }
                if (options.select) {
                    element.getElements(options.select).each(function(el) {
                        el.toolkit("inputSelect", "destroy");
                    });
                }
            } else {
                this.input.replaces(this.wrapper).removeProperty("style");
            }
        }
    });
    Toolkit.InputCheckbox = new Class({
        Extends: Toolkit.Input,
        initialize: function(checkbox, options) {
            this.input = checkbox;
            this.setOptions(options, checkbox);
            this.buildWrapper(checkbox);
            this.element = new Element("label." + vendor + "checkbox").set("for", checkbox.get("id")).inject(checkbox, "after");
            this.enable();
            this.fireEvent("init");
        }
    });
    Toolkit.InputRadio = new Class({
        Extends: Toolkit.Input,
        initialize: function(radio, options) {
            this.input = radio;
            this.setOptions(options, radio);
            this.buildWrapper(radio);
            this.element = new Element("label." + vendor + "radio").set("for", radio.get("id")).inject(radio, "after");
            this.enable();
            this.fireEvent("init");
        }
    });
    Toolkit.InputSelect = new Class({
        Extends: Toolkit.Input,
        Binds: [ "buildOption", "onChange", "onCycle", "onToggle" ],
        dropdown: null,
        multiple: false,
        index: 0,
        options: {
            "native": Toolkit.isTouch,
            multipleFormat: "count",
            countMessage: "{count} of {total} selected",
            listLimit: 3,
            hideOpened: true,
            hideFirst: false,
            hideSelected: false,
            arrowContent: '<span class="caret-down"></span>',
            getDefaultLabel: "title",
            getOptionLabel: "title",
            getDescription: "data-description"
        },
        initialize: function(select, options) {
            this.input = select;
            this.setOptions(options, select);
            this.multiple = select.multiple;
            if (select.multiple && this.options.native) {
                return;
            }
            var events = {
                "change input": "onChange"
            };
            this.buildWrapper(select);
            this.buildButton(select);
            if (!this.options.native) {
                events["blur input"] = "hide";
                events["clickout document .@select-options"] = "hide";
                events["clickout element"] = "hide";
                events["click element"] = "onToggle";
                if (!this.multiple) {
                    events["keydown window"] = "onCycle";
                }
                this.buildDropdown(select);
                select.setStyle("z-index", 1);
            }
            this.events = events;
            this.enable();
            this.fireEvent("init");
            this.input.fireEvent("change", {
                target: select
            });
        },
        buildButton: function(select) {
            this.element = new Element("div." + vendor + "select").grab(new Element("div." + vendor + "select-arrow").set("html", this.options.arrowContent)).grab(new Element("div." + vendor + "select-label").set("text", Toolkit.messages.loading)).setStyle("min-width", select.getWidth()).inject(select, "after");
            if (this.multiple) {
                this.input.setStyle("max-height", this.element.getHeight());
            }
            return this;
        },
        buildDropdown: function(select) {
            var options = this.options, buildOption = this.buildOption, dropdown = new Element("div." + vendor + "drop." + vendor + "drop--down." + vendor + "select-options"), list = new Element("ul"), index = 0;
            dropdown.set("role", "listbox").aria("multiselectable", this.multiple);
            this.dropdown = dropdown;
            Array.from(select.children).each(function(optgroup) {
                if (optgroup.get("tag") === "optgroup") {
                    if (index === 0) {
                        options.hideFirst = false;
                    }
                    list.grab(new Element("li").addClass(vendor + "drop-heading").set("text", optgroup.get("label")));
                    Array.from(optgroup.children).each(function(option) {
                        if (optgroup.disabled) {
                            option.disabled = true;
                        }
                        if (option.selected) {
                            this.index = index;
                        }
                        list.grab(buildOption(option, index));
                        index++;
                    }, this);
                } else {
                    if (optgroup.selected) {
                        this.index = index;
                    }
                    list.grab(buildOption(optgroup, index));
                    index++;
                }
            }, this);
            if (options.hideSelected && !options.multiple) {
                dropdown.addClass("hide-selected");
            }
            if (options.hideFirst) {
                dropdown.addClass("hide-first");
            }
            if (select.multiple) {
                dropdown.addClass("is-multiple");
            }
            this.wrapper.grab(dropdown.grab(list));
            return this;
        },
        buildOption: function(option, index) {
            var select = this.input, dropdown = this.dropdown, activeClass = "is-active", selected = option.selected;
            var li = new Element("li"), content = option.textContent, description;
            if (selected) {
                li.addClass(activeClass);
            }
            if (description = this.readValue(option, this.options.getDescription)) {
                content += ' <span class="' + vendor + 'drop-desc">' + description + "</span>";
            }
            var a = new Element("a").set({
                html: content,
                href: "javascript:;",
                role: "option"
            }).aria("selected", selected);
            if (this.options.copyClasses) {
                this.copyClasses(option, li);
            }
            li.grab(a);
            if (option.disabled) {
                li.addClass("is-disabled");
                a.aria("disabled", true);
                return li;
            }
            if (this.multiple) {
                a.addEvent("click", function() {
                    var selected = false;
                    if (option.selected) {
                        this.getParent().removeClass(activeClass);
                    } else {
                        selected = true;
                        this.getParent().addClass(activeClass);
                    }
                    option.selected = selected;
                    this.aria("selected", selected);
                    select.fireEvent("change", {
                        target: select
                    });
                });
            } else {
                var self = this;
                a.addEvent("click", function() {
                    dropdown.getElements("li").removeClass(activeClass);
                    dropdown.getElements("a").aria("selected", false);
                    this.getParent().addClass(activeClass);
                    this.aria("selected", true);
                    self.hide();
                    self.index = index;
                    select.set("value", option.value);
                    select.fireEvent("change", {
                        target: select
                    });
                });
            }
            return li;
        },
        hide: function() {
            if (this.element) {
                this.element.removeClass("is-active");
            }
            if (this.dropdown) {
                this.dropdown.conceal();
            }
            this.fireEvent("hide");
            return this;
        },
        show: function() {
            if (this.options.hideOpened) {
                $$("." + vendor + "drop.select-options").each(function(el) {
                    el.getSiblings("select").toolkit("inputSelect", "hide");
                });
            }
            this.element.addClass("is-active");
            if (this.dropdown) {
                this.dropdown.reveal();
            }
            this.fireEvent("show");
            return this;
        },
        _loop: function(index, step, options) {
            var hideFirst = this.options.hideFirst;
            index += step;
            while (typeof options[index] === "undefined" || options[index].disabled || index === 0 && hideFirst) {
                index += step;
                if (index >= options.length) {
                    index = 0;
                } else if (index < 0) {
                    index = options.length - 1;
                }
            }
            return index;
        },
        onChange: function(e) {
            var select = e.target, options = select.getElements("option"), selected = [], label = [];
            options.each(function(option) {
                if (option.selected) {
                    selected.push(option);
                    label.push(this.readValue(option, this.options.getOptionLabel) || option.textContent);
                }
            }, this);
            if (this.multiple) {
                var title = this.readValue(select, this.options.getDefaultLabel), format = this.options.multipleFormat, count = label.length;
                if (!label.length && title) {
                    label = title;
                } else if (format === "count") {
                    label = this.options.countMessage.replace("{count}", count).replace("{total}", options.length);
                } else if (format === "list") {
                    var limit = this.options.listLimit;
                    label = label.splice(0, limit).join(", ");
                    if (limit < count) {
                        label += " ...";
                    }
                }
            } else {
                label = label.join(", ");
            }
            select.getParent().getElement("." + vendor + "select-label").set("text", label);
            this.fireEvent("change", [ select.get("value"), selected ]);
        },
        onCycle: function(e) {
            if (!this.dropdown.isVisible()) {
                return;
            }
            if ([ "up", "down", "enter", "esc" ].contains(e.key)) {
                e.preventDefault();
            } else {
                return;
            }
            var options = this.input.getElements("option"), items = this.dropdown.getElements("a"), activeClass = "is-active", index = this.index;
            switch (e.key) {
              case "enter":
              case "esc":
                this.hide();
                return;

              case "up":
                index = this._loop(index, -1, options);
                break;

              case "down":
                index = this._loop(index, 1, options);
                break;
            }
            options.set("selected", false);
            options[index].selected = true;
            items.getParent().removeClass(activeClass);
            items[index].getParent().addClass(activeClass);
            this.index = index;
            this.input.fireEvent("change", {
                target: this.input
            });
        },
        onToggle: function() {
            if (this.input.disabled) {
                return;
            }
            if (this.dropdown.isShown()) {
                this.hide();
            } else {
                this.show();
            }
        }
    });
    Toolkit.create("input", function(options) {
        return new Toolkit.Input(this, options);
    });
    Toolkit.create("inputRadio", function(options) {
        return new Toolkit.InputRadio(this, options);
    });
    Toolkit.create("inputCheckbox", function(options) {
        return new Toolkit.InputCheckbox(this, options);
    });
    Toolkit.create("inputSelect", function(options) {
        return new Toolkit.InputSelect(this, options);
    });
    Toolkit.LazyLoad = new Class({
        Extends: Toolkit.Component,
        Binds: [ "load", "loadAll", "onReady" ],
        container: null,
        elements: [],
        isLoaded: false,
        loaded: 0,
        options: {
            forceLoad: false,
            delay: 1e4,
            threshold: 150,
            throttle: 50,
            context: null
        },
        initialize: function(container, options) {
            this.parent(options);
            this.options = this.inheritOptions(this.options, container);
            this.container = container.getStyle("overflow") === "auto" ? container : window;
            this.elements = container.getElements(".lazy-load");
            var events, throttle = this.options.throttle;
            this.events = events = {
                "ready document": "onReady"
            };
            events["scroll:throttle(" + throttle + ") container"] = "load";
            events["resize:throttle(" + throttle + ") window"] = "load";
            this.enable();
            this.fireEvent("init");
        },
        doDestroy: function() {
            this.loadAll();
        },
        inViewport: function(node) {
            var container = this.container, threshold = this.options.threshold, conSize = container.getSize(), scrollSize = container.getScroll(), nodeOffset = node.getPosition(container === window ? document.body : container);
            return node.isVisible() && nodeOffset.y >= scrollSize.y - threshold && nodeOffset.y <= scrollSize.y + conSize.y + threshold && nodeOffset.x >= scrollSize.x - threshold && nodeOffset.x <= scrollSize.x + conSize.x + threshold;
        },
        load: function() {
            if (this.loaded >= this.elements.length) {
                this.shutdown();
                return false;
            }
            this.elements.each(function(node, index) {
                if (node && this.inViewport(node)) {
                    this.show(node, index);
                }
            }, this);
            this.fireEvent("load");
            return true;
        },
        loadAll: function() {
            this.elements.each(function(node, index) {
                if (node) {
                    this.show(node, index);
                }
            }, this);
            this.fireEvent("loadAll");
            this.shutdown();
            return true;
        },
        show: function(node, index) {
            node.removeClass("lazy-load");
            node.getElements("img").each(function(image) {
                var src;
                if (Toolkit.isRetina) {
                    src = image.get("data-src-retina");
                }
                if (!src) {
                    src = image.get("data-src");
                }
                if (src) {
                    image.set("src", src);
                }
            });
            this.elements.splice(index, 1, null);
            this.loaded++;
            this.fireEvent("show", node);
            return this;
        },
        shutdown: function() {
            if (this.enabled) {
                this.disable();
                this.fireEvent("shutdown");
            }
            return this;
        },
        onReady: function() {
            this.load();
            if (this.options.forceLoad) {
                setTimeout(this.loadAll.bind(this), this.options.delay);
            }
        }
    });
    Toolkit.create("lazyLoad", function(options) {
        return new Toolkit.LazyLoad(this, options);
    });
    Toolkit.Mask = new Class({
        Extends: Toolkit.Component,
        Binds: [ "toggle" ],
        mask: null,
        message: null,
        options: {
            selector: "",
            revealOnClick: false,
            messageContent: ""
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = options = this.inheritOptions(this.options, element);
            var maskClass = "." + vendor + "mask";
            if (element !== document.body) {
                element.addClass(vendor + "mask-target");
                if (element.getStyle("position") === "static") {
                    element.setStyle("position", "relative");
                }
            }
            this.setMask(element.getElement("> " + maskClass) || new Element("div" + maskClass));
            if (options.selector) {
                this.events = {};
                this.events["click document " + options.selector] = "toggle";
            }
            this.enable();
            this.fireEvent("init");
        },
        doDestroy: function() {
            this.mask.dispose();
            this.element.removeClass(vendor + "mask-target").removeClass("is-masked").setStyle("position", "");
        },
        hide: function() {
            this.mask.conceal();
            this.element.removeClass("is-masked");
            this.fireEvent("hide");
            return this;
        },
        setMask: function(element) {
            var options = this.options;
            element.addClass("hide").inject(this.element, "bottom");
            if (this.element === document.body) {
                element.setStyle("position", "fixed");
            }
            if (options.revealOnClick) {
                element.addEvent("click", this.onHide);
            }
            this.mask = element;
            this.message = element.getElement("> ." + vendor + "mask-message");
            if (!this.message) {
                this.message = new Element("div." + vendor + "mask-message").inject(element, "bottom");
                if (options.messageContent) {
                    this.message.set("html", options.messageContent);
                }
            }
            return this;
        },
        show: function(node) {
            this.node = node;
            this.mask.reveal();
            this.element.addClass("is-masked");
            this.fireEvent("show");
            return this;
        },
        toggle: function() {
            return this.mask.isShown() ? this.hide() : this.show();
        }
    });
    Toolkit.create("mask", function(options) {
        return new Toolkit.Mask(this, options);
    });
    Toolkit.Matrix = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onResize", "onLoad" ],
        items: [],
        matrix: [],
        wrapperWidth: 0,
        colWidth: 0,
        colCount: 0,
        images: [],
        imagesLoaded: 0,
        options: {
            width: 200,
            gutter: 20,
            rtl: false,
            defer: true,
            template: false
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = this.inheritOptions(this.options, element);
            element.addClass(vendor + "matrix");
            this.items = element.getElements("> li");
            this.events = {
                "resize window": this.onResize.debounce()
            };
            this.enable();
            this.fireEvent("init");
            if (this.options.defer) {
                this._deferRender();
            } else {
                this.render();
            }
        },
        append: function(item) {
            item.inject(this.element, "bottom").setStyle("opacity", 0);
            return this.refresh();
        },
        doDestroy: function() {
            this.element.removeProperty("style");
            this.items.removeProperty("style");
        },
        prepend: function(item) {
            item.inject(this.element, "top").setStyle("opacity", 0);
            return this.refresh();
        },
        refresh: function() {
            this.items = this.element.getElements("> li");
            return this.render();
        },
        remove: function(item) {
            this.items.every(function(el) {
                if (el === item) {
                    el.destroy();
                    return false;
                }
                return true;
            });
            return this.refresh();
        },
        render: function() {
            this._calculateColumns();
            if (this.items.length < this.colCount) {
                this.element.removeProperty("style");
            } else if (this.colCount <= 1) {
                this.element.addClass("no-columns");
                this.items.removeProperty("style");
            } else {
                this.element.removeClass("no-columns");
                this._organizeItems();
                this._positionItems();
            }
            this.fireEvent("render");
            return this;
        },
        _calculateColumns: function() {
            var wrapperWidth = this.element.getSize().x, colWidth = this.options.width, gutter = this.options.gutter, cols = Math.max(Math.floor(wrapperWidth / colWidth), 1), colsWidth = cols * (colWidth + gutter) - gutter, diff;
            if (cols > 1) {
                if (colsWidth > wrapperWidth) {
                    diff = colsWidth - wrapperWidth;
                    colWidth -= diff / cols;
                } else if (colsWidth < wrapperWidth) {
                    diff = wrapperWidth - colsWidth;
                    colWidth += diff / cols;
                }
            }
            this.wrapperWidth = wrapperWidth;
            this.colWidth = colWidth;
            this.colCount = cols;
            return this;
        }.protect(),
        _deferRender: function() {
            this.imagesLoaded = 0;
            this.images = this.element.getElements("img");
            if (this.images.length) {
                this.images.each(function(image) {
                    var src = image.src;
                    image.onload = this.onLoad;
                    image.onerror = this.onLoad;
                    image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                    image.src = src;
                }, this);
            } else {
                this.render();
            }
            return this;
        }.protect(),
        _organizeItems: function() {
            var item, span, size, c = 0, l = this.items.length;
            this.matrix = [];
            for (var i = 0; i < l; i++) {
                item = this.items[i];
                size = item.getSize();
                span = Math.max(Math.round(size.x / this.colWidth), 1);
                this.matrix.push({
                    item: item,
                    span: span
                });
                if (span > 1) {
                    for (var s = 1; s < span; s++) {
                        c++;
                        if (this.matrix) {
                            this.matrix.push({
                                item: item,
                                span: false
                            });
                        }
                    }
                }
                c++;
                if (c >= this.colCount) {
                    c = 0;
                }
            }
            return this;
        }.protect(),
        _positionItems: function() {
            var gutter = this.options.gutter, items = this.matrix, item, span, dir = this.options.rtl ? "right" : "left", x = 0, y = [], top, c = 0, i, l, s, pos = {
                margin: 0,
                position: "absolute"
            };
            for (i = 0; i < this.colCount; i++) {
                y.push(0);
            }
            for (i = 0, l = items.length; i < l; i++) {
                item = items[i];
                span = item.span;
                if (c >= this.colCount || span + c > this.colCount) {
                    c = 0;
                    x = 0;
                }
                if (span) {
                    top = 0;
                    for (s = 0; s < span; s++) {
                        if (y[c + s] > top) {
                            top = y[c + s];
                        }
                    }
                    pos.top = top;
                    pos[dir] = x;
                    pos.width = (this.colWidth + gutter) * span - gutter;
                    item.item.setStyles(pos).reveal();
                    for (s = 0; s < span; s++) {
                        y[c + s] = item.item.getSize().y + gutter + top;
                    }
                }
                x += this.colWidth + gutter;
                c++;
            }
            this.element.setStyle("height", Math.max.apply(Math, y));
            return this;
        }.protect(),
        onLoad: function(e) {
            if (!e || e.type === "load" && e.target.complete || e.type === "error" && !e.target.complete) {
                this.imagesLoaded++;
            }
            if (this.imagesLoaded === this.images.length) {
                this.render();
            }
        },
        onResize: function() {
            this.refresh();
        }
    });
    Toolkit.create("matrix", function(options) {
        return new Toolkit.Matrix(this, options);
    });
    Toolkit.Modal = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onSubmit", "onKeydown" ],
        blackout: null,
        drag: null,
        elementBody: null,
        options: {
            delegate: ".js-modal",
            animation: "fade",
            ajax: true,
            blackout: true,
            fullScreen: false,
            stopScroll: true,
            getContent: "data-modal",
            template: '<div class="modal">' + '<div class="modal-outer">' + '<div class="modal-inner"></div>' + '<button class="modal-close modal-hide"><span class="x"></span></button>' + "</div>" + "</div>"
        },
        initialize: function(elements, options) {
            this.parent(options);
            this.nodes = elements;
            this.createElement();
            options = this.options;
            if (options.fullScreen) {
                this.element.addClass("is-fullscreen");
            }
            if (options.blackout) {
                this.blackout = Toolkit.Blackout.factory();
                if (options.stopScroll) {
                    this.blackout.addEvent("hide", function(hidden) {
                        if (hidden) {
                            document.body.removeClass("no-scroll");
                        }
                    });
                }
            }
            this.element.set("role", "dialog").aria("labelledby", this.id()).aria("describedby", this.id());
            this.events = {
                "keydown window": "onKeydown",
                "clickout element": "onHide",
                "clickout document {selector}": "onHide",
                "click document {selector}": "onShow",
                "click element .@modal-hide": "onHide",
                "click element .@modal-submit": "onSubmit"
            };
            this.enable();
            this.fireEvent("init");
        },
        hide: function() {
            if (this.blackout) {
                this.blackout.hide();
            }
            return this.parent();
        },
        position: function(content) {
            if (content === true) {
                return this;
            }
            if (this.blackout) {
                this.blackout.hideLoader();
            }
            var body = this.element.getElement("." + vendor + "modal-inner");
            body.set("html", content);
            this.fireEvent("load", content);
            this.element.reveal();
            if (this.options.fullScreen) {
                body.setStyle("min-height", window.getHeight());
            }
            this.fireEvent("show");
            return this;
        },
        show: function(node, content) {
            var options = this.options, ajax = options.ajax;
            if (content) {
                ajax = false;
            } else if (node) {
                this.node = node;
                ajax = this.readOption(node, "ajax");
                content = this.readValue(node, this.readOption(node, "getContent")) || node.get("href");
                if (content && content.match(/^#[a-z0-9_\-\.:]+$/i)) {
                    ajax = false;
                }
            }
            if (!content) {
                return this;
            }
            if (this.blackout && !this.element.isShown()) {
                this.blackout.show();
            }
            if (options.stopScroll) {
                document.body.addClass("no-scroll");
            }
            if (ajax) {
                if (this.cache[content]) {
                    this.position(this.cache[content]);
                } else {
                    this.requestData(content);
                }
            } else {
                this.position(content);
            }
            return this;
        },
        onKeydown: function(e) {
            if (e.key === "esc" && this.element.isShown()) {
                this.hide();
            }
        },
        onSubmit: function(e) {
            e.preventDefault();
            var button = e.target, form = this.element.getElement("form");
            if (!form) {
                return;
            }
            this.fireEvent("submit", [ button, form ]);
            var options = {
                url: form.get("action"),
                method: form.get("method").toUpperCase()
            };
            if (window.FormData) {
                options.data = new FormData(form);
            } else {
                options.data = form.toQueryString();
            }
            this.requestData(options);
        }
    });
    Toolkit.create("modal", function(options) {
        return new Toolkit.Modal(this, options);
    }, true);
    Toolkit.Pin = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onResize", "onScroll" ],
        viewport: null,
        elementSize: null,
        parentSize: null,
        elementTop: null,
        active: true,
        options: {
            location: "right",
            xOffset: 0,
            yOffset: 0,
            throttle: 50,
            fixed: false,
            calculate: false,
            lock: true
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = this.inheritOptions(this.options, element);
            element.set("role", "complementary").addClass(vendor + "pin").addClass(options.animation);
            this.elementTop = element.getStyle("top").toInt();
            var events, throttle = this.options.throttle;
            this.events = events = {
                "ready document": "onResize"
            };
            events["scroll:throttle(" + throttle + ") window"] = "onScroll";
            events["resize:throttle(" + throttle + ") window"] = "onResize";
            this.enable();
            this.fireEvent("init");
        },
        calculate: function() {
            var options = this.options;
            this.viewport = window.getSize();
            this.elementSize = this.element.getCoordinates();
            this.parentSize = this.element.getParent(options.context).getCoordinates();
            if (options.lock && this.elementSize.height >= this.viewport.y) {
                this.active = false;
            } else {
                this.active = this.element.isVisible() && this.parentSize.height > this.elementSize.height;
            }
            return this;
        },
        doDestroy: function() {
            this.active = false;
            this.element.reveal();
            setTimeout(function() {
                this.element.removeProperty("style").removeClass("is-pinned");
            }.bind(this), 10);
        },
        pin: function() {
            if (this.options.calculate) {
                this.calculate();
            }
            if (!this.active) {
                return;
            }
            var options = this.options, isFixed = options.fixed, eSize = this.elementSize, eTop = this.elementTop, pSize = this.parentSize, wScroll = window.getScroll(), pos = {}, x = options.xOffset, y = 0;
            if (wScroll.y < pSize.top) {
                this.element.removeProperty("style").removeClass("is-pinned");
                return;
            }
            var elementMaxPos = wScroll.y + eSize.height, parentMaxHeight = pSize.height + pSize.top;
            if (isFixed) {
                if (elementMaxPos >= parentMaxHeight) {
                    y = "auto";
                    pos.position = "absolute";
                    pos.bottom = 0;
                } else {
                    pos.position = "fixed";
                    pos.bottom = "auto";
                }
            } else {
                pos.position = "absolute";
                if (elementMaxPos >= parentMaxHeight) {
                    y += pSize.height - eSize.height;
                } else {
                    y += wScroll.y - pSize.top + options.yOffset;
                }
                if (eTop && y < eTop) {
                    y = eTop;
                }
            }
            pos[options.location] = x;
            pos.top = y;
            this.element.setStyles(pos).addClass("is-pinned");
        },
        onResize: function() {
            this.calculate();
            this.pin();
            this.fireEvent("resize");
        },
        onScroll: function() {
            this.pin();
            this.fireEvent("scroll");
        }
    });
    Toolkit.create("pin", function(options) {
        return new Toolkit.Pin(this, options);
    });
    Toolkit.Tooltip = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onFollow" ],
        elementHead: null,
        elementBody: null,
        options: {
            delegate: ".js-tooltip",
            mode: "hover",
            ajax: false,
            follow: false,
            position: "top-center",
            showLoading: true,
            showTitle: true,
            getTitle: "title",
            getContent: "data-tooltip",
            mouseThrottle: 50,
            xOffset: 0,
            yOffset: 0,
            delay: 0,
            template: '<div class="tooltip">' + '<div class="tooltip-inner">' + '<div class="tooltip-head"></div>' + '<div class="tooltip-body"></div>' + "</div>" + '<div class="tooltip-arrow"></div>' + "</div>"
        },
        runtime: {},
        initialize: function(elements, options) {
            this.parent(options);
            this.nodes = elements;
            this.createElement();
            options = this.options;
            var title = "data" + this.cssClass + "-title";
            this.elementHead = this.element.getElement("." + vendor + this.cssClass + "-head");
            this.elementBody = this.element.getElement("." + vendor + this.cssClass + "-body");
            this.element.set("role", "tooltip").removeClass(options.className);
            this.nodes.each(function(node) {
                node.setProperty(title, node.get("title")).removeProperty("title");
            });
            if (options.getTitle === "title") {
                options.getTitle = title;
            }
            var events = {
                "{mode} document {selector}": "onShow"
            };
            if (options.mode === "click") {
                events["clickout element"] = "onHide";
                events["clickout document {selector}"] = "onHide";
            } else {
                events["mouseleave document {selector}"] = "onHide";
            }
            this.events = events;
            this.enable();
            this.fireEvent("init");
        },
        hide: function() {
            var options = this.options, element = this.element, position = element.get("data-new-position") || this.runtime.position || options.position, className = this.runtime.className || options.className, callback = function() {
                element.removeClass(position).removeClass(className).removeProperty("data-new-position");
            };
            this.runtime = {};
            if (options.animation) {
                element.one(Toolkit.transitionEnd, callback);
            } else {
                callback();
            }
            if (this.node) {
                this.node.removeProperty("aria-describedby");
            }
            return this.parent();
        },
        position: function(content, title) {
            var options = Object.keys(this.runtime).length ? this.runtime : this.options;
            if (content === true) {
                return this;
            }
            this.element.addClass(options.position).addClass(options.className);
            if (this.node) {
                this.node.aria("describedby", this.id());
            }
            title = title || this.readValue(this.node, options.getTitle);
            if (title && options.showTitle) {
                this.elementHead.set("html", title).show();
            } else {
                this.elementHead.hide();
            }
            if (content) {
                this.elementBody.set("html", content).show();
            } else {
                this.elementBody.hide();
            }
            this.fireEvent("load", content);
            if (options.follow) {
                var event = "mousemove:throttle(" + options.mouseThrottle + ")";
                this.node.removeEvent(event, this.onFollow).addEvent(event, this.onFollow);
                this.fireEvent("show");
            } else {
                this.element.positionTo(options.position, this.node, {
                    left: options.xOffset,
                    top: options.yOffset
                });
                setTimeout(function() {
                    this.element.reveal();
                    this.fireEvent("show");
                }.bind(this), options.delay || 0);
            }
            return this;
        },
        show: function(node, content, title) {
            var options;
            if (node) {
                this.node = node;
                this.runtime = options = this.inheritOptions(this.options, node);
                content = content || this.readValue(node, options.getContent);
            } else {
                this.runtime = options = this.options;
            }
            if (!content) {
                return this;
            }
            if (options.ajax) {
                if (this.cache[content]) {
                    this.position(this.cache[content], title);
                } else {
                    if (options.showLoading) {
                        this.position(Toolkit.messages.loading);
                    }
                    this.requestData(content);
                }
            } else {
                this.position(content, title);
            }
            return this;
        },
        onFollow: function(e) {
            e.preventDefault();
            var options = this.runtime;
            this.element.positionTo(options.position, e, {
                left: options.xOffset,
                top: options.yOffset
            }, true).reveal();
        }
    });
    Toolkit.create("tooltip", function(options) {
        return new Toolkit.Tooltip(this, options);
    }, true);
    Toolkit.Popover = new Class({
        Extends: Toolkit.Tooltip,
        options: {
            delegate: ".js-popover",
            getContent: "data-popover",
            template: '<div class="popover">' + '<div class="popover-inner">' + '<div class="popover-head"></div>' + '<div class="popover-body"></div>' + "</div>" + '<div class="popover-arrow"></div>' + "</div>"
        },
        initialize: function(query, options) {
            options = options || {};
            options.mode = "click";
            options.follow = false;
            this.parent(query, options);
        }
    });
    Toolkit.create("popover", function(options) {
        return new Toolkit.Popover(this, options);
    }, true);
    Toolkit.Showcase = new Class({
        Extends: Toolkit.Component,
        Binds: [ "next", "prev", "onJump", "onSwipe", "onKeydown" ],
        items: null,
        tabs: null,
        caption: null,
        data: [],
        index: -1,
        blackout: null,
        options: {
            delegate: ".js-showcase",
            blackout: true,
            stopScroll: true,
            gutter: 50,
            getCategory: "data-showcase",
            getImage: "href",
            getTitle: "title",
            template: '<div class="showcase">' + '<div class="showcase-inner">' + '<ul class="showcase-items"></ul>' + '<ol class="showcase-tabs bullets"></ol>' + '<button class="showcase-prev"><span class="arrow-left"></span></button>' + '<button class="showcase-next"><span class="arrow-right"></span></button>' + "</div>" + '<button class="showcase-close showcase-hide"><span class="x"></span></button>' + '<div class="showcase-caption"></div>' + "</div>"
        },
        initialize: function(elements, options) {
            this.parent(options);
            this.nodes = elements;
            this.createElement();
            this.items = this.element.getElement("." + vendor + "showcase-items");
            this.tabs = this.element.getElement("." + vendor + "showcase-tabs");
            this.caption = this.element.getElement("." + vendor + "showcase-caption");
            if (this.options.blackout) {
                this.blackout = Toolkit.Blackout.factory();
            }
            this.events = {
                "clickout element": "onHide",
                "clickout document {selector}": "onHide",
                "swipe element": "onSwipe",
                "keydown window": "onKeydown",
                "click document {selector}": "onShow",
                "click element .@showcase-hide": "onHide",
                "click element .@showcase-next": "next",
                "click element .@showcase-prev": "prev",
                "click element .@showcase-tabs a": "onJump"
            };
            this.enable();
            this.fireEvent("init");
        },
        hide: function() {
            if (this.blackout) {
                this.blackout.hide();
            }
            if (this.options.stopScroll) {
                document.body.removeClass("no-scroll");
            }
            this.parent(function() {
                this.element.removeClass("is-single");
                this.items.removeProperty("style").getElements("li").conceal();
            }.bind(this));
            return this;
        },
        jump: function(index) {
            index = Number.from(index).bound(this.data.length);
            if (index === this.index) {
                return this;
            }
            var self = this, element = this.element, caption = this.caption, list = this.items, listItems = list.getElements("li"), listItem = listItems[index], items = this.data, item = items[index];
            if (this.tabs) {
                var listTabs = this.tabs.getElements("a");
                listTabs.removeClass("is-active");
                listTabs[index].addClass("is-active");
            }
            listItems.conceal();
            caption.conceal();
            listItems.addEvent(Toolkit.transitionEnd, function(e) {
                e.stopPropagation();
            });
            var callback = function() {
                caption.set("html", item.title).reveal();
                listItem.reveal();
                self.position();
            };
            list.addEvent(Toolkit.transitionEnd + ":once", callback);
            if (listItem.hasAttribute("data-width")) {
                this._resize(listItem.get("data-width").toInt(), listItem.get("data-height").toInt());
                if (!Toolkit.hasTransition) {
                    callback();
                }
            } else {
                element.addClass("is-loading").aria("busy", true);
                var img = new Image();
                img.src = item.image;
                img.onload = function() {
                    self._resize(this.width, this.height);
                    element.removeClass("is-loading").aria("busy", false);
                    listItem.set("data-width", this.width).set("data-height", this.height).grab(img);
                    if (!Toolkit.hasTransition) {
                        callback();
                    }
                };
                img.onerror = function() {
                    element.removeClass("is-loading").addClass("has-failed").aria("busy", false);
                    listItem.set("data-width", 150).set("data-height", 150).set("html", Toolkit.messages.error);
                    self._resize(150, 150);
                    if (!Toolkit.hasTransition) {
                        callback();
                    }
                };
            }
            this.index = index;
            this.fireEvent("jump", index);
            return this;
        },
        next: function() {
            this.jump(this.index + 1);
            return this;
        },
        position: function() {
            if (this.blackout) {
                this.blackout.hideLoader();
            }
            this.element.reveal();
            this.fireEvent("show");
            return this;
        },
        prev: function() {
            this.jump(this.index - 1);
            return this;
        },
        show: function(node) {
            this.node = node;
            this.index = -1;
            this.element.addClass("is-loading").aria("busy", true);
            var options = this.inheritOptions(this.options, node), read = this.readValue, category = read(node, options.getCategory), items = [], index = 0;
            if (category) {
                for (var i = 0, x = 0, n; n = this.nodes[i]; i++) {
                    if (read(n, options.getCategory) === category) {
                        if (n === node) {
                            index = x;
                        }
                        items.push({
                            title: read(n, options.getTitle),
                            category: category,
                            image: read(n, options.getImage)
                        });
                        x++;
                    }
                }
            } else {
                items.push({
                    title: read(node, options.getTitle),
                    category: category,
                    image: read(node, options.getImage)
                });
            }
            if (this.blackout) {
                this.blackout.show();
            }
            if (options.stopScroll) {
                document.body.addClass("no-scroll");
            }
            this._buildItems(items);
            this.jump(index);
            return this;
        },
        _buildItems: function(items) {
            this.data = items;
            this.items.empty();
            this.tabs.empty();
            for (var li, a, item, i = 0; item = items[i]; i++) {
                li = new Element("li");
                li.inject(this.items);
                a = new Element("a").set("href", "javascript:;").set("data-index", i);
                li = new Element("li");
                li.inject(this.tabs).grab(a);
            }
            if (items.length <= 1) {
                this.element.addClass("is-single");
            }
            this.fireEvent("load", items);
            return this;
        }.protect(),
        _resize: function(width, height) {
            var size = window.getSize(), gutter = this.options.gutter * 2, wWidth = size.x - gutter, wHeight = size.y - gutter, ratio, diff;
            if (width > wWidth) {
                ratio = width / height;
                diff = width - wWidth;
                width = wWidth;
                height -= Math.round(diff / ratio);
            } else if (height > wHeight) {
                ratio = height / width;
                diff = height - wHeight;
                width -= Math.round(diff / ratio);
                height = wHeight;
            }
            this.items.setStyles({
                width: width,
                height: height
            });
            return this;
        },
        onJump: function(e) {
            e.preventDefault();
            this.jump(e.target.get("data-index") || 0);
        },
        onKeydown: function(e) {
            if (this.isVisible()) {
                if ([ "up", "down", "left", "right" ].contains(e.key)) {
                    e.preventDefault();
                }
                switch (e.key) {
                  case "esc":
                    this.hide();
                    break;

                  case "up":
                    this.jump(0);
                    break;

                  case "down":
                    this.jump(-1);
                    break;

                  case "left":
                    this.prev();
                    break;

                  case "right":
                    this.next();
                    break;
                }
            }
        },
        onSwipe: function(e) {
            if (e.direction === "left") {
                this.next();
            } else if (e.direction === "right") {
                this.prev();
            }
        }
    });
    Toolkit.create("showcase", function(options) {
        return new Toolkit.Showcase(this, options);
    }, true);
    Toolkit.Stalker = new Class({
        Extends: Toolkit.Component,
        Binds: [ "onScroll" ],
        container: null,
        targets: [],
        markers: [],
        offsets: [],
        options: {
            target: "",
            targetBy: "href",
            marker: "",
            markBy: "id",
            threshold: 50,
            throttle: 50,
            onlyWithin: true,
            applyToParent: true
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.container = element.getStyle("overflow") === "auto" ? element : window;
            if (!this.options.target || !this.options.marker) {
                throw new Error("A marker and target is required");
            }
            element.addClass(vendor + "stalker");
            var events;
            this.events = events = {
                "ready document": "onScroll"
            };
            events["scroll:throttle(" + this.options.throttle + ") container"] = "onScroll";
            this.enable();
            this.fireEvent("init");
            this.refresh();
        },
        activate: function(marker) {
            this._stalk(marker, "activate");
            return this;
        },
        deactivate: function(marker) {
            this._stalk(marker, "deactivate");
            return this;
        },
        doDestroy: function() {
            var targets = this.targets, markers = this.markers;
            targets.removeClass(vendor + "stalker-target");
            markers.removeClass(vendor + "stalker-marker");
            if (this.options.applyToParent) {
                targets.getParent().removeClass("is-active");
                markers.getParent().removeClass("is-marked");
            } else {
                targets.removeClass("is-active");
                markers.removeClass("is-marked");
            }
        },
        refresh: function() {
            if (this.element.getStyle("overflow") === "auto" && this.element !== document.body) {
                this.element.scrollTop = 0;
            }
            this.targets = $$(this.options.target).addClass(vendor + "stalker-target");
            this.markers = $$(this.options.marker).addClass(vendor + "stalker-marker");
            this.offsets = this.markers.getCoordinates(this.element);
            return this;
        },
        _stalk: function(marker, type) {
            if (type === "activate" && marker.hasClass("is-stalked")) {
                return;
            }
            var targetBy = this.options.targetBy, markBy = this.options.markBy, method = type === "activate" ? "addClass" : "removeClass", target = this.targets.filter(function(item) {
                return item.get(targetBy).replace("#", "") === marker.get(markBy);
            });
            marker[method]("is-stalked");
            if (this.options.applyToParent) {
                target.getParent()[method]("is-active");
            } else {
                target[method]("is-active");
            }
            this.fireEvent(type, [ marker, target ]);
        },
        onScroll: function() {
            var scroll = this.container.getScroll().y, markers = this.markers, offsets = this.offsets, onlyWithin = this.options.onlyWithin, threshold = this.options.threshold;
            markers.each(function(marker, index) {
                var coords = offsets[index], top = coords.top - threshold, bot = coords.top + coords.height + threshold;
                if (onlyWithin && scroll >= top && scroll <= bot || !onlyWithin && scroll >= top) {
                    this.activate(marker);
                } else {
                    this.deactivate(marker);
                }
            }.bind(this));
            this.fireEvent("scroll");
        }
    });
    Toolkit.create("stalker", function(options) {
        return new Toolkit.Stalker(this, options);
    });
    Toolkit.Tabs = new Class({
        Extends: Toolkit.Component,
        nav: null,
        sections: [],
        tabs: [],
        index: 0,
        options: {
            ajax: true,
            collapsible: false,
            defaultIndex: 0,
            persistState: false,
            preventDefault: true,
            loadFragment: true,
            cookie: null,
            cookieDuration: 30,
            getUrl: "href",
            template: false
        },
        initialize: function(element, options) {
            this.parent(options);
            this.element = element;
            this.options = options = this.inheritOptions(this.options, element);
            if (!options.cookie) {
                options.cookie = element.get("id");
            }
            this.sections = element.getElements("." + vendor + "tabs-section").each(function(section, index) {
                section.set("role", "tabpanel").set("id", section.get("id") || this.id("section", index)).aria("labelledby", this.id("tab", index)).conceal();
            }.bind(this));
            this.nav = element.getElement("." + vendor + "tabs-nav").set("role", "tablist");
            this.tabs = this.nav.getElements("a").each(function(tab, index) {
                tab.set({
                    "data-index": index,
                    role: "tab",
                    id: this.id("tab", index)
                }).aria({
                    controls: this.sections[index].get("id"),
                    selected: false,
                    expanded: false
                }).removeClass("is-active");
            }.bind(this));
            this.events = {};
            this.events["{mode} element .@tabs-nav a"] = "onShow";
            if (options.mode !== "click" && options.preventDefault) {
                this.events["click element .@tabs-nav a"] = function(e) {
                    e.preventDefault();
                };
            }
            this.enable();
            this.fireEvent("init");
            var index = options.defaultIndex;
            if (options.persistState) {
                index = Number.from(Cookie.read("toolkit.tabs." + options.cookie));
            }
            if (!index && options.loadFragment && location.hash) {
                var tab = this.tabs.filter(function(el) {
                    return el.get("href") === location.hash;
                });
                if (tab[0]) {
                    index = tab[0].get("data-index");
                }
            }
            if (!index || !this.tabs[index]) {
                index = 0;
            }
            this.jump(index);
        },
        doDestroy: function() {
            this.element.reveal();
            this.sections[this.index].reveal();
        },
        hide: function() {
            this.sections.conceal();
            this.fireEvent("hide", this.node);
            return this;
        },
        jump: function(index) {
            return this.show(this.tabs[Number.from(index).bound(this.tabs.length)]);
        },
        show: function(tab) {
            var index = tab.get("data-index"), section = this.sections[index], options = this.options, ajax = this.readOption(tab, "ajax"), url = this.readValue(tab, this.readOption(tab, "getUrl"));
            if (ajax && url && url.substr(0, 1) !== "#" && !this.cache[url]) {
                this.requestData(url, function() {
                    section.set("html", Toolkit.messages.loading).addClass("is-loading").aria("busy", true);
                }.bind(this), function(response) {
                    if (options.cache) {
                        this.cache[url] = true;
                    }
                    this.fireEvent("load", response);
                    section.set("html", response).removeClass("is-loading").aria("busy", false);
                }.bind(this), function() {
                    section.set("html", Toolkit.messages.error).removeClass("is-loading").addClass("has-failed").aria("busy", false);
                }.bind(this));
            }
            this.tabs.aria({
                selected: false,
                expanded: false
            }).getParent().removeClass("is-active");
            if (index === this.index && options.collapsible) {
                if (section.isVisible()) {
                    section.conceal();
                } else {
                    tab.aria({
                        selected: true,
                        expanded: true
                    }).getParent().addClass("is-active");
                    section.reveal();
                }
            } else {
                this.hide();
                tab.aria({
                    selected: true,
                    expanded: true
                }).getParent().addClass("is-active");
                section.reveal();
            }
            if (options.persistState) {
                Cookie.write("toolkit.tabs." + options.cookie, index, {
                    duration: options.cookieDuration
                });
            }
            this.index = index;
            this.node = tab;
            this.fireEvent("show", tab);
            return this;
        },
        onShow: function(e, node) {
            if (this.options.preventDefault || this.options.ajax && e.target.get("href").substr(0, 1) !== "#") {
                e.preventDefault();
            }
            this.show(node);
        }
    });
    Toolkit.create("tabs", function(options) {
        return new Toolkit.Tabs(this, options);
    });
    Toolkit.TypeAhead = new Class({
        Extends: Toolkit.Component,
        Implements: [ Cache ],
        Binds: [ "source", "rewind", "onCycle", "onFind", "onLookup" ],
        input: null,
        shadow: null,
        index: -1,
        items: [],
        term: "",
        timer: null,
        options: {
            source: [],
            minLength: 1,
            itemLimit: 15,
            throttle: 250,
            prefetch: false,
            shadow: false,
            storage: "session",
            query: {},
            template: '<div class="type-ahead"></div>',
            sorter: null,
            matcher: null,
            builder: null
        },
        initialize: function(input, options) {
            this.parent(options);
            this.createElement();
            this.options = options = this.inheritOptions(this.options, input);
            this.input = input;
            if (input.get("tag") !== "input") {
                throw new Error("TypeAhead must be initialized on an input field");
            }
            this.setStorage(options.storage);
            Object.each({
                sorter: "sort",
                matcher: "match",
                builder: "build"
            }, function(fn, key) {
                if (options[key] === false) {
                    return;
                }
                var callback;
                if (options[key] === null || typeOf(options[key]) !== "function") {
                    callback = this[fn];
                } else {
                    callback = options[key];
                }
                this.options[key] = callback.bind(this);
            }.bind(this));
            if (options.prefetch && typeOf(options.source) === "string") {
                var url = options.source;
                new Request.JSON({
                    url: url,
                    data: options.query,
                    onSuccess: function(items) {
                        this.setCache(url, items);
                    }.bind(this)
                }).get();
            }
            if (options.shadow) {
                this.node = new Element("div." + vendor + "type-ahead-shadow").wraps(this.input);
                this.shadow = this.input.clone().addClass("is-shadow").removeProperty("id").set("readonly", true).aria("readonly", true).inject(this.node, "top");
                this.input.addClass("not-shadow");
            }
            input.set({
                autocomplete: "off",
                autocapitalize: "off",
                autocorrect: "off",
                spellcheck: "false",
                role: "combobox"
            }).aria({
                autocomplete: "list",
                owns: this.element.get("id"),
                expanded: false
            });
            this.element.set("role", "listbox").aria("multiselectable", false);
            this.events = {
                "keyup input": "onLookup",
                "keydown input": "onCycle",
                "clickout element": "onHide"
            };
            this.enable();
            this.fireEvent("init");
        },
        build: function(item) {
            var a = new Element("a", {
                href: "javascript:;",
                role: "option",
                "aria-selected": "false"
            });
            a.grab(new Element("span." + vendor + "type-ahead-title", {
                html: this.highlight(item.title)
            }));
            if (item.description) {
                a.grab(new Element("span." + vendor + "type-ahead-desc", {
                    html: item.description
                }));
            }
            return a;
        },
        doDestroy: function() {
            if (this.shadow) {
                this.input.replaces(this.shadow.getParent()).removeClass("not-shadow");
            }
        },
        hide: function() {
            if (this.shadow) {
                this.shadow.set("value", "");
            }
            this.input.aria("expanded", false);
            return this.parent();
        },
        highlight: function(item) {
            var terms = this.term.replace(/[\-\[\]\{\}()*+?.,\\^$|#]/g, "\\$&").split(" "), callback = function(match) {
                return '<mark class="' + vendor + 'type-ahead-highlight">' + match + "</mark>";
            };
            for (var i = 0, t; t = terms[i]; i++) {
                item = item.replace(new RegExp(t, "ig"), callback);
            }
            return item;
        },
        lookup: function(term) {
            this.term = term;
            this.timer = setTimeout(this.onFind, this.options.throttle);
            return this;
        },
        match: function(item, term) {
            return item.toLowerCase().indexOf(term.toLowerCase()) >= 0;
        },
        position: function() {
            if (!this.items.length) {
                return this.hide();
            }
            var iPos = this.input.getCoordinates();
            this.element.setPosition({
                x: iPos.left,
                y: iPos.top + iPos.height
            }).reveal();
            this.input.aria("expanded", true);
            return this;
        },
        rewind: function() {
            this.index = -1;
            this.element.getElements("li").removeClass("is-active");
            return this;
        },
        select: function(index, event) {
            this.index = index;
            var rows = this.element.getElements("li");
            rows.removeClass("is-active");
            this.element.getElements("a").aria("selected", false);
            if (index >= 0) {
                if (this.items[index]) {
                    var item = this.items[index];
                    rows[index].addClass("is-active").getElements("a").aria("selected", true);
                    this.input.set("value", item.title);
                    this.fireEvent(event || "select", [ item, index ]);
                }
            } else {
                this.input.set("value", this.term);
                this.fireEvent("reset");
            }
            return this;
        },
        sort: function(items) {
            return items.sort(function(a, b) {
                return a.title.localeCompare(b.title);
            });
        },
        source: function(items) {
            if (!this.term.length || !items.length) {
                this.hide();
                return this;
            }
            var options = this.options, categories = {
                _empty_: []
            }, item, list = new Element("ul");
            this.items = [];
            this.index = -1;
            if (typeOf(options.sorter) === "function") {
                items = options.sorter(items);
            }
            if (typeOf(options.matcher) === "function") {
                items = items.filter(function(item) {
                    return options.matcher(item.title, this.term);
                }.bind(this));
            }
            for (var i = 0; item = items[i]; i++) {
                if (item.category) {
                    if (!categories[item.category]) {
                        categories[item.category] = [];
                    }
                    categories[item.category].push(item);
                } else {
                    categories._empty_.push(item);
                }
            }
            var results = [], count = 0;
            Object.each(categories, function(items, category) {
                var elements = new Elements();
                if (category !== "_empty_") {
                    results.push(null);
                    elements.push(new Element("li").addClass(vendor + "type-ahead-heading").grab(new Element("span", {
                        text: category
                    })));
                }
                for (var i = 0, a; item = items[i]; i++) {
                    if (count >= options.itemLimit) {
                        break;
                    }
                    a = options.builder(item);
                    a.addEvents({
                        mouseover: this.rewind,
                        click: this.onSelect.pass(results.length, this)
                    });
                    elements.push(new Element("li").grab(a));
                    results.push(item);
                    count++;
                }
                elements.inject(list);
            }.bind(this));
            this.element.empty().grab(list);
            this.items = results;
            this.cache[this.term.toLowerCase()] = results.filter(function(item) {
                return item !== null;
            });
            this.fireEvent("load");
            this._shadow();
            this.position();
            this.fireEvent("show");
            return this;
        },
        _shadow: function() {
            if (!this.shadow) {
                return this;
            }
            var term = this.input.get("value"), termLower = term.toLowerCase(), value = "";
            if (this.cache[termLower] && this.cache[termLower][0]) {
                var title = this.cache[termLower][0].title;
                if (title.toLowerCase().indexOf(termLower) === 0) {
                    value = term + title.substr(term.length, title.length - term.length);
                }
            }
            this.shadow.set("value", value);
            return this;
        }.protect(),
        onCycle: function(e) {
            var items = this.items, length = items.length.limit(0, this.options.itemLimit), event = "cycle";
            if (!length || !this.isVisible()) {
                return;
            }
            switch (e.key) {
              case "up":
                this.index -= items[this.index - 1] ? 1 : 2;
                if (this.index < 0) {
                    this.index = length;
                }
                break;

              case "down":
                this.index += items[this.index + 1] ? 1 : 2;
                if (this.index >= length) {
                    this.index = -1;
                }
                break;

              case "tab":
                e.preventDefault();
                var i = 0;
                while (!this.items[i]) {
                    i++;
                }
                event = "select";
                this.index = i;
                this.hide();
                break;

              case "enter":
                e.preventDefault();
                event = "select";
                this.hide();
                break;

              case "esc":
                this.index = -1;
                this.hide();
                break;

              default:
                return;
            }
            if (this.shadow) {
                this.shadow.set("value", "");
            }
            this.select(this.index, event);
        },
        onFind: function() {
            var term = this.term, options = this.options, sourceType = typeOf(options.source);
            if (this.cache[term.toLowerCase()]) {
                this.source(this.cache[term.toLowerCase()]);
            } else if (sourceType === "string") {
                var url = options.source, cache = this.getCache(url);
                if (cache) {
                    this.source(cache);
                } else {
                    var query = options.query;
                    query.term = term;
                    new Request.JSON({
                        url: url,
                        data: query,
                        onSuccess: this.source
                    }).get();
                }
            } else if (sourceType === "array") {
                this.source(options.source);
            } else if (sourceType === "function") {
                var response = options.source.attempt([], this);
                if (response) {
                    this.source(response);
                }
            } else {
                throw new Error("Invalid TypeAhead source type");
            }
        },
        onLookup: function(e) {
            if ([ "up", "down", "esc", "tab", "enter" ].contains(e.key)) {
                return;
            }
            clearTimeout(this.timer);
            var term = this.input.get("value").trim();
            if (term.length < this.options.minLength) {
                this.fireEvent("reset");
                this.hide();
            } else {
                this._shadow();
                this.lookup(term);
            }
        },
        onSelect: function(index) {
            this.select(index);
            this.hide();
        }
    });
    Toolkit.create("typeAhead", function(options) {
        return new Toolkit.TypeAhead(this, options);
    });
})(window, jQuery);